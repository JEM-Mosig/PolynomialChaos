(* ::Package:: *)

BeginPackage["PolynomialChaos`"]

Needs["PolynomialChaos`SubOptions`"]
Needs["PolynomialChaos`FastIntegrate`"]
Needs["PolynomialChaos`MultiIndex`"]

Begin["PolynomialChaos`"]


(* ::Section:: *)
(*Public Definitions*)


ClearAll[
	DistributionSupport,
	GPCBasis,
	GPCMatrix,
	Collocation,
	CollocationData,
	ConstructRule
]


(* ::Subsection:: *)
(*DistributionSupport*)


If[Not@ValueQ[DistributionSupport::usage],
	DistributionSupport::usage = "DistributionSupport[distr] returns the domain {min, max} for the GPC scalar product to be used with the given distribution."
];

SyntaxInformation[DistributionSupport] = {
	"ArgumentsPattern" -> {_}
};


(* ::Subsection:: *)
(*GPCBasis*)


If[Not@ValueQ[GPCBasis::usage],
	GPCBasis::usage = "GPCBasis[{x, distr}, n] constructs the first gPC basis polynomials in x up to order n for the distribution distr."
];

Options[GPCBasis] = {
	Epilog -> Simplify`QuickSimplify,
	Method -> {
		Automatic,
		Method -> Automatic
		(*"Integrator" -> Integrate*)
	},
	DistributionSupport -> Automatic,
	Ordering -> "GradedLexicographic",
	"CombineDimensions" -> True,
	WorkingPrecision -> Infinity
};

SyntaxInformation[GPCBasis] = {
	"ArgumentsPattern" -> {__, OptionsPattern[]},
	"LocalVariables" -> {"Table", {1, -2}}
};


(* ::Subsection:: *)
(*GPCMatrix*)


If[Not@ValueQ[GPCMatrix::usage],
	GPCMatrix::usage = "GPCMatrix[kernel, {x, distr}, n] constructs the nth order GPC matrix \[LeftAngleBracket]Subscript[P, i] kernel Subscript[P, j]\[RightAngleBracket] for the gPC polynomials of distr."
];

Options[GPCMatrix] = {
	Method -> {"Integrator" -> Automatic},
	Epilog -> Simplify`QuickSimplify
};

SyntaxInformation[GPCMatrix] = {
	"ArgumentsPattern" -> {_, {_, __}, _, OptionsPattern[]},
	"LocalVariables" -> {"Table", {2, -2}}
};


(* ::Subsection:: *)
(*Collocation*)


If[Not@ValueQ[Collocation::usage],
	Collocation::usage = "Collocation[f, {x, distr}, n] returns {expectation, variance} of f[x] when x is distributed according to distr, using a generalized polynomial chaos collocation method with up to nth order gPC polynomials."
];

Options[Collocation] = {
	Method -> "PseudoSpectral",
	"DistributionSupport" -> Automatic,
	Listable -> False,
	Abs -> False,
	Epilog -> Identity,
	MaxSteps -> 0,
	AccuracyGoal -> Automatic,
	PrecisionGoal -> Automatic,
	EvaluationMonitor -> None,
	StepMonitor -> None,
	Monitor -> None,
	"Moments" -> 2,
	"EvaluationDump" -> None,
	Debug -> None
};

SyntaxInformation[Collocation] = {
	"ArgumentsPattern" -> {_, {_, _}.., _, OptionsPattern[]},
	"LocalVariables" -> {"Integrate", {2, -2}}
};


(* ::Subsection:: *)
(*CollocationData*)


If[Not@ValueQ[CollocationData::usage],
	CollocationData::usage = "CollocationData[\[Ellipsis]] is generated by Collocation."
];


(* ::Subsection:: *)
(*ConstructRule*)


If[Not@ValueQ[ConstructRule::usage],
	ConstructRule::usage = "ConstructRule[n, distr] returns a list with {n abscissas, n weights} for the Gauss quadrature with the gPC basis of the given distribution distr."
];

Options[ConstructRule] = {
	Monitor -> None
};

SyntaxInformation[ConstructRule] = {
	"ArgumentsPattern" -> {_, __, OptionsPattern[]}
};


(* ::Section:: *)
(*Private Definitions*)


Begin["`Private`"]


(* ::Subsection:: *)
(*DistributionSupport*)


DistributionSupport::domain = "Cannot determine the scalar product domain for the distribution `1`. If available, use the option \"DistributionSupport\" -> {min, max} to specify the domain.";

(* function which determines the interval {a,b} on which a given distribution distr is non-zero *)
DistributionSupport[distr_?DistributionParameterQ] := Block[{x}, 
	With[{
			(* save the precision of quantities in the given distribution *)
			prec = Precision[distr],
			(* find the condition under which the PDF of distr is non-zero *)
			(* SetPrecision is used because Reduce often only works with exact numbers *)
			cond = Quiet[Reduce[PDF[SetPrecision[distr, \[Infinity]], x] != 0, x, Reals], {Reduce::ratnz}]
		},
		(* convert the condition to a list {min, max} *)
		Switch[cond,
			True, {-Infinity, Infinity},
			Inequality[_, ___, _], (cond /. Inequality[a_, ___, b_] :> Sort[{a, b}]),
			x > _, (cond /. x > a_ :> {a, Infinity}),
			x < _, (cond /. x < a_ :> {-Infinity, a}),
			_, Message[DistributionSupport::domain, distr]; {Indeterminate, Indeterminate}
		] // (SetPrecision[#, prec]&) (* adjust the precision to the input *)
	]
] /; FreeQ[{TruncatedDistribution, CensoredDistribution}, Head[distr]];

DistributionSupport[TruncatedDistribution[{a_, b_}, fdistr_?DistributionParameterQ]] := MinMax@IntervalIntersection[
	Interval@DistributionSupport[fdistr],
	Interval@{a,b}
];

DistributionSupport[CensoredDistribution[{a_, b_}, fdistr_?DistributionParameterQ]] := (Print["!"];MinMax@IntervalIntersection[
	Interval@DistributionSupport[fdistr],
	Interval@{a,b}
]);

DistributionSupport["Uniform"] = {-1,1};
DistributionSupport["Beta"] = {-1,1};


(* ::Subsection:: *)
(*GPCBasis*)


GPCBasis::n = "`1` is not Function, nor a positive integer.";


GPCBasis[{x_, distr_?DistributionParameterQ}, n_Integer?NonNegative, OptionsPattern[]] := Module[{z},
	Which[SubOption[OptionValue[Method]] === Automatic,
		Switch[distr,
			(* any linearly transformed distribution *)
			TransformedDistribution[_?(Length[Variables[#]]<=1&&PolynomialQ[#, Variables[#]]&&Exponent[#, First@Variables[#]] <= 1&), z_ \[Distributed] _?DistributionParameterQ],
			With[{
					(* extract linear and first-order coefficients of the transformation polynomial *)
					a = Coefficient[distr[[1]], First@Variables[distr[[1]]], 0],
					b = Coefficient[distr[[1]], First@Variables[distr[[1]]], 1]
				},
				(* compute basis for untransformed distribution and then transform the result *)
				GPCBasis[{z, distr[[2,2]]}, n] /. {z -> (x - a) / b}
			],
			(* uniform distribution *)
			UniformDistribution[],
			`subGPCBasis`uniform[Range[0, n], {0, 1}, x],
			UniformDistribution[{_, _}],
			`subGPCBasis`uniform[Range[0, n], distr[[1]], x],
			(* Beta distribution *)
			BetaDistribution[_, _], 
			`subGPCBasis`beta[Range[0, n], distr[[1]], distr[[2]], x],
			(* normal distribution *)
			_NormalDistribution,
			`subGPCBasis`normal[Range[0, n], Mean[distr], StandardDeviation[distr], x], 
			(* truncated normal distribution *)
			TruncatedDistribution[{_?NonNegative, _?NonNegative}, _NormalDistribution],
			`subGPCBasis`truncNormal[n, Mean[distr[[2]]], StandardDeviation[distr[[2]]], Min[distr[[1]]], Max[distr[[1]]], OptionValue[WorkingPrecision], x],
			(* truncated normal distribution on interval [0, \[Infinity]) *)
			HalfNormalDistribution[_],
			`subGPCBasis`truncNormal[n, 0, Sqrt[\[Pi]/2] / distr[[1]], 0, \[Infinity], OptionValue[WorkingPrecision], x],
			(* any other continuous distribution with existing PDF  *)
			_,
			`subGPCBasis`general[
				distr, x, n, 
				SubOption[OptionValue[Method], "Orthogonalization", Automatic], 
				SubOption[OptionValue[Method], "Integrator", If[OptionValue[WorkingPrecision] === \[Infinity], Simplify`QuickSimplify@*Integrate, NIntegrate[##, WorkingPrecision -> OptionValue[WorkingPrecision]]&]], 
				If[OptionValue[DistributionSupport] === Automatic,
					Check[DistributionSupport[distr], Abort[]],
					(* since here the support may be {{min, max}} or {min, max}, use Flatten *)
					Flatten@OptionValue[DistributionSupport]
				]
			]
		]
		,
		SubOption[OptionValue[Method]] == "Orthogonalize" || SubOption[OptionValue[Method]] == Orthogonalize,
		`subGPCBasis`general[
			distr, x, n, 
			SubOption[OptionValue[Method], Method, Automatic], 
			SubOption[OptionValue[Method], "Integrator", If[OptionValue[WorkingPrecision] === \[Infinity], Simplify`QuickSimplify@*Integrate, NIntegrate[##, WorkingPrecision -> OptionValue[WorkingPrecision]]&]], 
			If[OptionValue[DistributionSupport] === Automatic,
				Check[DistributionSupport[distr], Abort[]],
				(* since here the support may be {{min, max}} or {min, max}, use Flatten *)
				Flatten@OptionValue[DistributionSupport]
			]
		]
	] // OptionValue[Epilog]
]


GPCBasis[{x_, "Uniform"}, n_Integer?NonNegative, options:OptionsPattern[]] := GPCBasis[
	{x, UniformDistribution[{-1,1}]}, 
	n, options
]


GPCBasis[{x_, "Beta"}, n_Integer?NonNegative, options:OptionsPattern[]] := GPCBasis[
	{x, TransformedDistribution[2 x - 1, x \[Distributed] BetaDistribution[10,10]]}, 
	n, options
]


(* return functional forms if only the distribution is given *)

GPCBasis[distr_?DistributionParameterQ, OptionsPattern[]] := (
	Switch[distr,
		UniformDistribution[],
		Function[{\[FormalN], \[FormalX]}, Evaluate[`subGPCBasis`uniform[\[FormalN], {0, 1}, \[FormalX]]]],
		UniformDistribution[{_, _}],
		Block[{a = distr[[1]]}, Function[{\[FormalN], \[FormalX]}, Evaluate[`subGPCBasis`uniform[\[FormalN], a, \[FormalX]]]]],
		BetaDistribution[_, _], 
		Block[{a = distr[[1]], b = distr[[2]]}, Function[{\[FormalN], \[FormalX]}, Evaluate[`subGPCBasis`beta[\[FormalN], a, b, \[FormalX]]]]],
		NormalDistribution[],
		Function[{\[FormalN], \[FormalX]}, Evaluate[`subGPCBasis`normal[\[FormalN], 0, 1, \[FormalX]]]], 
		NormalDistribution[_, _],
		Block[{a = distr[[1]], b = distr[[2]]}, Function[{\[FormalN], \[FormalX]}, Evaluate[`subGPCBasis`normal[\[FormalN], a, b, \[FormalX]]]]],
		_,
		Missing["NotAvailable"]
	] // OptionValue[Epilog]
)


(* deal with multiple variables *)

GPCBasis[args:{_, _?DistributionParameterQ}.., n_Integer?NonNegative, OptionsPattern[]] := Module[
	{
		dimension = Length[{args}],
		indexRange, mil, basis
	},
	(* generate a list of multi-indices in graded lexicographic order *)
	indexRange = Length[mil = MultiIndexList[dimension, n, Ordering -> OptionValue[Ordering]]];
	
	(* generate a basis for each variable *)
	basis = Table[
		GPCBasis[
			Part[{args}, i], n, 
			Method -> OptionValue[Method],
			DistributionSupport -> With[{sup = OptionValue[DistributionSupport]},
				Which[
					sup === Automatic, 
					Automatic, 
					(* the user may have specified the support specifically for each variable *)
					MatrixQ[sup] && Length[sup] == dimension,
					sup[[i]],
					(* use the same support for each variable *)
					VectorQ[sup] && Length[sup] == 2,
					sup,
					(* invalid argument *)
					True,
					Automatic (* ToDo: replace with warning message *)
				]
			]
		], 
		{i, dimension}
	];
	
	If[TrueQ[OptionValue["CombineDimensions"]],
		(* combine basis' *)
		Table[
			Product[basis[[j, mil[[i,j]] + 1]], {j, dimension}],
			{i, indexRange}
		]
		,
		basis
	] // OptionValue[Epilog]
]


Begin["`subGPCBasis`"]


(* general definition for arbitrary distribution distr *)
ClearAll[general];
general[distr_, \[Alpha]_, n_, orthoMethod_, integrate_, {\[Alpha]min_, \[Alpha]max_}] := With[{
		product = Function[{a, b}, integrate[Expand[a b PDF[distr, \[Alpha]]], {\[Alpha], \[Alpha]min, \[Alpha]max}]]
	},
	Orthogonalize[
		Table[\[Alpha]^i, {i, 0, n}],
		product,
		Method -> orthoMethod
	]
]


ClearAll[uniform];
uniform[n_, {a_, b_}, x_] := Sqrt[((1 + 2*n))]*LegendreP[n, (a + b - 2*x)/(a - b)]


ClearAll[beta];
beta[n_, a_, b_, x_] := Sqrt[((-1+a+b+2 n) Beta[a,b] n! Gamma[-1+a+b+n])/(Gamma[a+n] Gamma[b+n])] JacobiP[n,b-1,a-1,2x-1]


ClearAll[normal];
normal[n_, \[Mu]_, \[Sigma]_, x_] := Sqrt[1/(2^n*n!)]*HermiteH[n, (x-\[Mu])/(Sqrt[2] \[Sigma])]


ClearAll[truncNormal];
truncNormal[n_, 0, \[Sigma]_, a_, b_, prec_, x_] := Module[{\[Mu] = 0, \[Gamma], i, normf, scalarProduct},
	(* the truncation changes the normalization by the CDF evaluated *)
	(* at the end-points a and b, i.e. *)
	normf = 1/2 Erfc[(-b + \[Mu])/(Sqrt[2] \[Sigma])] - 1/2 Erfc[(-a + \[Mu])/(Sqrt[2] \[Sigma])];
	If[prec =!= Infinity, normf = N[normf, prec]];
	
	(* we can find an analytic formula for the integral *)
	(* Integrate[x^i PDF[NormalDistribution[0,\[Sigma]],x],{x,a,b}] *)
	(* the expression depends, however, on the assumptions made *)
	Which[
		0 <= a < b,
		\[Gamma][i_] := (2^(-1 + i/2)*\[Sigma]^i*(Gamma[(1 + i)/2, a^2/(2*\[Sigma]^2)] 
			- Gamma[(1 + i)/2, b^2/(2*\[Sigma]^2)])) / Sqrt[Pi]
		,
		a < b <= 0,
		\[Gamma][i_] := (2^(-1 + i/2)*(-\[Sigma])^i*(-Gamma[(1 + i)/2, a^2/(2*\[Sigma]^2)] 
			+ Gamma[(1 + i)/2, b^2/(2*\[Sigma]^2)])) / Sqrt[Pi]
		,
		a < 0 < b,
		\[Gamma][i_] := (2^(-1 + i/2)*\[Sigma]^i*((1 + (-1)^i)*Gamma[(1 + i)/2] 
			+ (-1)^(1 + i)*Gamma[(1 + i)/2, a^2/(2*\[Sigma]^2)] - Gamma[(1 + i)/2, b^2/(2*\[Sigma]^2)]))/Sqrt[Pi]
		,
		True,
		Abort[]
	];
	
	(* we can use this to define the scalar product *)
	scalarProduct[poly1_, poly2_] := 
	With[{coefs = CoefficientList[poly1 poly2, x]},
		coefs.Table[\[Gamma][i], {i, 0, Length[coefs] - 1}] / normf // Simplify`QuickSimplify
	];
	
	If[prec === Infinity,
		(* construct the basis symbolically *)
		Orthogonalize[Table[x^i, {i, 0, n}], scalarProduct]
		,
		(* construct the basis using numerical approximations *)
		Orthogonalize[Table[x^i, {i, 0, n}], N[scalarProduct[##], prec]&]
	]
] /; a < b

truncNormal[n_, \[Mu]_, \[Sigma]_, a_, b_, prec_, x_] := (
	truncNormal[n, 0, \[Sigma], a - \[Mu], b - \[Mu], prec, x] /. x -> x - \[Mu]
) /; \[Mu] != 0


End[] (* `subGPCBasis` *)


(* ::Subsection:: *)
(*GPCMatrix*)


(* general argument case (single random variable) *)

GPCMatrix[kernels_, {x_, distr_?DistributionParameterQ}, n_Integer?Positive, options:OptionsPattern[]] := Module[{a, b, epilog = (OptionValue[Epilog] /. None -> Identity)},
	{a, b} = DistributionSupport[distr];
	With[{
			basis = GPCBasis[{x, distr}, n],
			pdf = Refine[PDF[distr][x], a < x < b] (* use Refine to get rid of Piecewise *)
		},
		GPCMatrix[kernels, {x, basis, pdf, a, b}, n, options] // epilog
	]
]


(* general argument case (multiple random variables) *)

GPCMatrix[kernels_, vars:{_, _?DistributionParameterQ}.., n_Integer?Positive, options:OptionsPattern[]] := Module[{supports, pdfs, epilog = (OptionValue[Epilog] /. None -> Identity)},
	(* determine the support for each random variable *)
	supports = Table[
		DistributionSupport[{vars}[[i, 2]]],
		{i, Length[{vars}]}
	];
	
	(* determine the PDF for each random variable *)
	pdfs = Table[
		(* use Refine to get rid of Piecewise *)
		Refine[PDF[{vars}[[i, 2]], {vars}[[i, 1]]], supports[[i, 1]] < {vars}[[i, 1]] < supports[[i, 2]]],
		{i, Length[{vars}]}
	];
	
	With[{
			basis = GPCBasis[vars, n, DistributionSupport -> supports],
			pdf = Times@@pdfs
		},
		GPCMatrix[kernels, {{vars}[[All, 1]], basis, pdf, supports}, n, options] // epilog
	]
]


(* special argument case: "Uniform" *)

GPCMatrix[c_?NumberQ, {x_, "Uniform"}, n_Integer?Positive, OptionsPattern[]] := c `subGPCMatrix`uniformMono[0, n]

GPCMatrix[c_?NumberQ x_, {x_, "Uniform"}, n_Integer?Positive, OptionsPattern[]] := c `subGPCMatrix`uniformMono[1, n]

GPCMatrix[c_?NumberQ x_^2, {x_, "Uniform"}, n_Integer?Positive, OptionsPattern[]] := c `subGPCMatrix`uniformMono[2, n]

GPCMatrix[kernels_List, {x_, "Uniform"}, n_Integer?Positive, OptionsPattern[]] := Table[
	GPCMatrix[kernel, {x, "Uniform"}, n],
	{kernel, kernels}
]

GPCMatrix[kernel_, {x_, "Uniform"}, n_Integer?Positive, OptionsPattern[]] := With[{epilog = (OptionValue[Epilog] /. None -> Identity)},
	GPCMatrix[kernel, {x, UniformDistribution[{-1,1}]}, n] // epilog
]


(* special argument case: "Beta" *)

GPCMatrix[kernels_, {x_, "Beta"}, n_Integer?Positive, options:OptionsPattern[]] := With[{epilog = (OptionValue[Epilog] /. None -> Identity)},
	GPCMatrix[
		kernels,
		{x, GPCBasis[{x, "Beta"}, n], 230945/131072 (1 - x^2)^9, -1, 1}, n,
		Method -> {"Integrator" -> IntegratePolynomial}
	] // epilog
]


(* general argument case with explicit basis and pdf -- multiple kernels *)

GPCMatrix[kernels_List, {x_, basis_, pdf_, a_, b_}, n_Integer?Positive, options:OptionsPattern[]] := Table[
	`subGPCMatrix`general[
		basis, pdf, kernel, {x, a, b}, 
		OptionValue[Method -> "Integrator"]
	],
	{kernel, kernels}
]


(* general argument case with explicit basis and pdf -- single kernel *)

GPCMatrix[kernel_, {x_, basis_, pdf_, a_, b_}, n_Integer?Positive, options:OptionsPattern[]] := `subGPCMatrix`general[
	basis, pdf, kernel, {x, a, b}, 
	OptionValue[Method -> "Integrator"]
]


(* general argument case with explicit basis and pdf -- multiple kernels, multiple random variables *)

GPCMatrix[kernels_List, {xyz_List, basis_, pdf_, supports_List}, n_Integer?Positive, options:OptionsPattern[]] := Table[
	`subGPCMatrix`general[
		basis, pdf, kernel, {xyz, supports}, 
		OptionValue[Method -> "Integrator"]
	],
	{kernel, kernels}
]


(* general argument case with explicit basis and pdf -- single kernel,  multiple random variables *)

GPCMatrix[kernel_, {xyz_List, basis_, pdf_, supports_List}, n_Integer?Positive, options:OptionsPattern[]] := `subGPCMatrix`general[
	basis, pdf, kernel, {xyz, supports}, 
	OptionValue[Method -> "Integrator"]
]


Begin["`subGPCMatrix`"]


(* single random variable *)

general[basis_, pdf_, kernel_, {x_, x0_, x1_}, integrator_] := Module[{n, integrate, res},
	n = Length[basis]; 
	integrate = If[integrator === Automatic, 
		(* Automatic means to use exact integrations for polynomials and numeric integration for other functions *)
		Which[
			TrueQ@PolynomialQ[pdf, x] && TrueQ@PolynomialQ[kernel, x],
			(* perform exact integration for polynomials *)
			IntegratePolynomial,
			True,
			(* perform numeric integration for other functions *)
			(* specify a finite AccuracyGoal since we can expect some results to be exactly zero *)
			Chop[NIntegrate[##, AccuracyGoal -> MachinePrecision], 10^(2-$MachinePrecision)]&
		], 
		integrator
	];
	(* iteratively construct a symmetric matrix of scalar products *)
	res = ConstantArray[0, {n, n}];
	Do[
		res[[i,j]] = res[[j,i]] = integrate[
			Expand[basis[[i]] basis[[j]] kernel pdf], {x, x0, x1}
		],
		{i, 1, n}, {j, 1, i}
	];
	res
]


(* multiple random variables *)

general[basis_, pdf_, kernel_, {xyz_List, supports_List}, integrator_] := Module[{n, integrate, res},
	n = Length[basis]; 
	integrate = If[integrator === Automatic, 
		(* Automatic means to use exact integrations for polynomials and numeric integration for other functions *)
		Which[
			TrueQ@PolynomialQ[pdf, xyz] && TrueQ@PolynomialQ[kernel, xyz],
			(* perform exact integration for polynomials *)
			IntegratePolynomial,
			True,
			(* perform numeric integration for other functions *)
			(* specify a finite AccuracyGoal since we can expect some results to be exactly zero *)
			Chop[NIntegrate[##, AccuracyGoal -> MachinePrecision], 10^(2-$MachinePrecision)]&
		], 
		integrator
	];
	(* iteratively construct a symmetric matrix of scalar products *)
	res = ConstantArray[0, {n, n}];
	Do[
		res[[i,j]] = res[[j,i]] = integrate[
			Expand[basis[[i]] basis[[j]] kernel pdf], Sequence@@Table[{xyz[[k]], supports[[k,1]], supports[[k,2]]}, {k, Length[xyz]}]
		],
		{i, 1, n}, {j, 1, i}
	];
	res
]


(* ::Text:: *)
(*On the MathWorld site about the Legendre polynomials we find general expressions for these matrices with kernels x and x^2.*)


(* this is just the orthogonality condition *)
uniformMono[0, n_] := IdentityMatrix[n + 1]


(* see http://mathworld.wolfram.com/LegendrePolynomial.html or Arfken 1985, p. 700 *)
uniformMono[1, n_] := SparseArray[{
		(* first sub-diagonals *)
		({i_,j_} /; j == i+1) :> With[{m = i-1, p = j-1}, Sqrt[1+2p] Sqrt[1+2m] p/((2p-1)(2p+1))],
		({i_,j_} /; j == i-1) :> With[{p = i-1, m = j-1}, Sqrt[1+2p] Sqrt[1+2m] p/((2p-1)(2p+1))]
	},
	{n + 1, n + 1}
]


(* see http://mathworld.wolfram.com/LegendrePolynomial.html or Arfken 1985, p. 700 *)
uniformMono[2, n_] := SparseArray[{
		(* main diagonal *)
		{i_,i_} :> With[{m = i-1}, (1+2m) (2m^2+2m-1)/((2m-1)(2m+1)(2m+3))],
		(* second sub-diagonals *)
		({i_,j_} /; i == j+2) :> With[{m=i-1,p=j-1}, Sqrt[m+p-1] Sqrt[1+2m] (m(m-1))/((2m-3)(2m-1)(2m+1))],
		({i_,j_} /; i == j-2) :> With[{p=i-1,m=j-1}, Sqrt[m+p-1] Sqrt[1+2m] (m(m-1))/((2m-3)(2m-1)(2m+1))]
	},
	{n + 1, n + 1}
]


End[] (* `subGPCMatrix` *)


(* ::Subsection:: *)
(*Collocation*)


Collocation::bdmtd = "\"`1`\" is not a valid collocation method.";
Collocation::bdspt = "\"`1`\" is not a valid support specification.";
Collocation::bdrule = "\"`1`\" is not a valid integration rule specification.";
Collocation::bdtype = "\"`1`\" is not a valid interpolation type.";
Collocation::bdgrid = "\"`1`\" is not a valid grid specification.";
Collocation::n = "The number of collocation points `1` must be at least 3.";
Collocation::smpm = "\"`1`\" is not a valid sampling method.";
Collocation::bdmom = "The \"Moments\" option `1` must be either 1 or 2.";
Collocation::nodir = "The directory `1` does not exist.";
Collocation::bddistr = "`1` is not a valid probability distribution.";


Collocation[expr_, args:{(*x*)_, (*distr*)_}.., n_Integer, options:OptionsPattern[]] := Catch[
	Module[{
			supports,
			extraPts = 0,
			previousResult = Indeterminate,
			result = Indeterminate,
			error = Indeterminate,
			aGoal = OptionValue[AccuracyGoal] /. Automatic -> Infinity,
			pGoal = OptionValue[PrecisionGoal] /. Automatic -> Infinity,
			startTime = AbsoluteTime[]
		},
		(* check if spcified number of collocation points is sufficiently large *)
		If[n < 3, Message[Collocation::n, n]; Throw[$Failed]];
	
		(* check if "Moments" option is ok *)
		If[!TrueQ[IntegerQ[OptionValue["Moments"]] && 1 <= OptionValue["Moments"] <= 2],
			Message[Collocation::bdmom, OptionValue["Moments"]]; Throw[$Failed]
		];
	
		(* determine the scalar product interval *)
		If[OptionValue["DistributionSupport"] === Automatic,
			(* attempt to automatically determine the distribution's supports *)
			supports = DistributionSupport[Last[#]]& /@ {args},
			(* use user-specifications *)
			supports = If[VectorQ[OptionValue["DistributionSupport"]],
				(* the user gave a single support {min, max} for all distributions *)
				{OptionValue["DistributionSupport"]},
				(* the user gave supports for each individual distribution {{min1, max1}, {min2, max2}, ...} *)
				OptionValue["DistributionSupport"]
			]
		];
		(* check if support specification is valid *)
		If[Not@MatrixQ[supports, MatchQ[_?NumericQ|Infinity|-Infinity] || Length[supports] != Length[{args}]], 
			Message[Collocation::bdspt, supports]; Throw[$Failed]
		];
	
		(* iterate until accuracy / precision goals are achieved *)
		While[
			And[
				(* respect MaxSteps *)
				TrueQ[extraPts <= OptionValue[MaxSteps]],
				(* check if error is still too big *)
				Or[
					(* no previous computation *)
					error === Indeterminate,
					(* compare error(s) to goals *)
					If[Head[error] === List,
						Not@TrueQ[And@@Thread[error < {1,1} 10^-aGoal + Abs[result] 10^-pGoal]],
						Not@TrueQ[And@@Thread[Flatten[List@@error] < ConstantArray[1, 2 Length[error]] 10^-aGoal + Abs[Flatten[List@@result]] 10^-pGoal]]
					]
				]
			],
			previousResult = result;
		
			(* choose method and compute result *)
			result = Switch[SubOption[OptionValue[Method]],
				"Interpolation",
				`Collocation`Interpolation[expr, args, n + extraPts, supports,
					FilterRules[Join[{options}, Options[Collocation]], Options[`Collocation`Interpolation]]
				],
				"PseudoSpectral",
				`Collocation`PseudoSpectral[expr, args, n + extraPts, supports,
					FilterRules[Join[{options}, Options[Collocation]], Options[`Collocation`PseudoSpectral]]
				],
				"MonteCarlo"|"QuasiMonteCarlo",
				`Collocation`MonteCarlo[expr, args, n + extraPts, supports,
					FilterRules[Join[{options}, Options[Collocation]], Options[`Collocation`MonteCarlo]]
				]
			];
			(* the result is a CollocationData object *)
			(* ask it for the estimated error *)
			error = result["ErrorEstimate"];
		
			(* iterate *)
			If[error === Indeterminate, error = Abs[result - previousResult]];
			OptionValue[StepMonitor][{result, error}];
			extraPts++;
		];
		
		(* return the result with the computation time appended to it *)
		CollocationData[<|First@result, "AbsoluteTiming" -> (AbsoluteTime[] - startTime)|>]
	]
]


(* ::Subsubsection:: *)
(*`Collocation`Interpolation*)


Options[`Collocation`Interpolation] = {
	Method -> "Interpolation",
	"DistributionSupport" -> Automatic,
	Listable -> False,
	Abs -> False,
	EvaluationMonitor -> None,
	"Moments" -> 2,
	"EvaluationDump" -> None
};

`Collocation`Interpolation[expr_, args:{(*x*)_, (*distr*)_}.., n_Integer, supports_, options:OptionsPattern[]] := Catch[
	With[{
			(* determine the dimension of the random space *)
			dim = Length[{args}],	
			(* determine the variables *)
			vars = First /@ {args},
			(* determine the distributions *)
			distributions = Last /@ {args},
			(* read in various options *)
			type = SubOption[OptionValue[Method], "InterpolationType", "LeastSquares"],
			sampling = SubOption[OptionValue[Method], "Sampling", "Equidistant"],
			grid = SubOption[OptionValue[Method], "Grid", "FullTensorGrid"]
		},
	
		(* check if "type" is valid *)
		If[!MemberQ[{"LeastSquares", "Lagrange", "Spline"(*, "Wavelet"*)}, type],
			Message[Collocation::bdtype, type]; Throw[$Failed]
		];
		(* check if "sampling" is valid *)
		If[!MemberQ[{"Equidistant", "gPC-roots", "Random", "RandomVariate"}, sampling],
			Message[Collocation::bdtype, type]; Throw[$Failed]
		];
	
		(* "grid" can be either "FullTensorGrid" or "SmolyakSparseGrid" *)
		If[!MemberQ[{"FullTensorGrid", "SmolyakSparseGrid"}, grid],
			Message[Collocation::bdgrid, grid]; Throw[$Failed]
		];
	
		Module[{
				f, memf, absc, fvalues, result, error, 
				(* all evaluations of expr will be stored in *)
				evalTable = {}
			},
			absc = Switch[sampling,
				"Equidistant", Tuples[Table[Subdivide[supports[[d, 1]], supports[[d, 2]], n - 1], {d, dim}]],
				"Random", RescalingTransform[ConstantArray[{0, 1}, dim], supports]@RandomReal[{0, 1}, {n - 1, dim}]
			];	
		
			f = Activate@Inactive[Function][First/@{args}, expr];
		
			(* inject EvaluationMonitor if required *)
			If[OptionValue[EvaluationMonitor] =!= None,
				f = InterceptedFunction[OptionValue[EvaluationMonitor], f]
			];
		
			(* construct a memory-function since evaluation of f is assumed to be very slow *)
			(* here this is actually only neccessary to deal with the EvaluationDump, as f
			will be evaluated only once ???? *)
			memf[a___] := With[{fa = f[a]}, AppendTo[evalTable, {{a}, fa}]; memf[a] = fa; fa];
			(* check if the evaluation dump file was specified *)
			If[OptionValue["EvaluationDump"] =!= None,
				(* inject EvaluationDumpFunction *)
				f = InterceptedFunction[EvaluationDumpFunction[OptionValue["EvaluationDump"]], f];
				(* see if we can use existing data *)
				If[FileExistsQ[OptionValue["EvaluationDump"]],
					(* load function values which already exist in the dump file *)
					Module[{str, line, count = 0},
						str = OpenRead[OptionValue["EvaluationDump"]];
						Check[
							CheckAbort[
								While[(line = ToExpression@ReadLine[str]) =!= EndOfFile,
									memf[Sequence@@First[line]] = Last[line];
									count++
								];
								Close[str],
								Close[str]
							],
							Close[str];
							Abort[]
						];
						PrintTemporary[ToString[count]<>" points read from "<>OptionValue["EvaluationDump"]]
					]
				]
			];
		
			(* evaluate f at root locations *)
			If[TrueQ@OptionValue[Listable],
				(* assume f is Listable *)
				fvalues = memf[absc],
				(* assume f is not Listable *) 
				fvalues = Apply[Sequence, Thread[Inactive[memf][absc]], {2}] // Activate
			];
		
			{result, error} = Switch[type,
				"LeastSquares", 
				LeastSquaresInterpolation[absc, fvalues, args, SubOption[OptionValue[Method], "Order", n],
					FilterRules[Join[{options}, Options[`Collocation`Interpolation]], Options[LeastSquaresInterpolation]]
				],
				_, Abort[]
			];
		
			CollocationData[
				<|
					"Method" -> SubOption[OptionValue[Method]],
					"MethodOption" -> OptionValue[Method],
					"RandomDimension" -> dim,
					"MomentList" -> result,
					"ErrorEstimate" -> Indeterminate,
					"BasisFunctions" -> Missing["NotApplicable"],
					"CoefficientList" -> Missing["NotApplicable"],
					"DistributionList" -> distributions,
					"SupportList" -> supports,
					"CompressedEvaluationTable" -> Compress[evalTable],
					"EvaluationCount" -> Length[evalTable]
				|>
			]
		]
	]
]


ClearAll[LeastSquaresInterpolation];

Options[LeastSquaresInterpolation] = {
	EvaluationMonitor -> None,
	"Moments" -> 2,
	Abs -> False
};

LeastSquaresInterpolation[pts_, fvalues_, args:{(*x*)_, (*distr*)_}.., order_Integer, OptionsPattern[]] := Module[{vars, distributions, basis, \[Chi], a, result},
	(* determine the variables *)
	vars = First /@ {args};
	(* determine the distributions *)
	distributions = Last /@ {args};
	
	(* construct n`th order gPC basis expression *)
	basis = GPCBasis[args, order, Ordering -> (True &)];
	
	(* construct the system matrix *)
	\[Chi] = N[Table[basis /. Thread[vars -> pt], {pt, pts}], $MachinePrecision];
	
	(* optimize coefficients by least-squares method 
	(equivalent to LinearSolve if n == Length[pts]) *)
	a = LeastSquares[\[Chi], fvalues];
	
	(* compute expectation, variance, etc. *)
	result = If[TrueQ[OptionValue[Abs]],
		(*ToMomentsAbs[a, basis, Times@@Table[PDF[distributions\[LeftDoubleBracket]i\[RightDoubleBracket], vars\[LeftDoubleBracket]i\[RightDoubleBracket]], {i, Length[vars]}], vars, supports, OptionValue["Moments"]]*)
		Abort[]
		,
		ToMoments[a, OptionValue["Moments"]]
	];
	
	(* return the result and drop the imaginary part (which should be zero) *)
	{If[Re[result] == result, Re[result], result], Indeterminate}
]


(*LagrangeInterpolation[]*)


(* ::Subsubsection:: *)
(*`Collocation`PseudoSpectral*)


Options[`Collocation`PseudoSpectral] = {
	Method -> "PseudoSpectral",
	Listable -> False,
	Abs -> False,
	EvaluationMonitor -> None,
	"Moments" -> 2,
	"EvaluationDump" -> None,
	Monitor -> None,
	Debug -> None
};

`Collocation`PseudoSpectral[expr_, args:{(*x*)_, (*distr*)_}.., order_Integer, supports_, options:OptionsPattern[]] := Catch[
	Module[{
			(* determine the dimension of the random space *)
			dim = Length[{args}],	
			(* determine the variables *)
			vars = First /@ {args},
			(* determine the distributions *)
			distributions = Last /@ {args},
			(* read in various options *)
			rule = SubOption[OptionValue[Method], "IntegrationRule", Automatic],
			grid = SubOption[OptionValue[Method], "Grid", "FullTensorGrid"],
			(* declare other local symbols *)
			basis, P, pdfs, f, memf, rulef, gridf, a, result, noUseAutoRule,
			(* all evaluations of expr will be stored in *)
			evalTable = {}
		},
	
		(* "rule" can be specified in two ways: either as single rule to apply to all dimensions, 
		or as a list of rules, one for each dimension. *)
		If[!AllTrue[Flatten[{rule}], MatchQ[Alternatives@@{Automatic, "GaussRule", "ClenshawCurtisRule", "TrapezoidalRule", "NewtonCotesRule", Association[__]}]],
			Message[Collocation::bdrule, rule]; Throw[$Failed]
		];
		If[Head[rule] === List && Length[rule] != Length[{args}],
			Message[Collocation::bdrule, rule]; Throw[$Failed]
		];
	
		(* "grid" can be either "FullTensorGrid" or "SmolyakSparseGrid" *)
		If[!MemberQ[{"FullTensorGrid", "SmolyakSparseGrid"}, grid],
			Message[Collocation::bdgrid, grid]; Throw[$Failed]
		];
	
		pdfs = Table[
			(* PDFEx is like PDF, but also trats special arguments such as "Uniform" or "Beta" *)
			PDFEx[distributions[[i]], vars[[i]]],
			{i, Length[distributions]}
		];
	
		(* the algorithm is different if we construct our own quadrature rule, or
		if we use one of the standard rules - generate a True/False Pick-list telling
		what we use in which dimension *)
		noUseAutoRule = If[ListQ[rule],
			Table[StringQ[r], {r, rule}],
			ConstantArray[StringQ[rule], dim]
		];
	
		(* see if basis is provided *)
		If[SubOption[OptionValue[Method], "GPCBasis"] === Automatic,
			(* construct gPC basis expression *)
			OptionValue[Monitor]["constructing gPC basis..."];
			basis = GPCBasis[args, order - 1, Ordering -> (True &), "DistributionSupport" -> supports];
			(* convert gPC basis expressions into functions *)
			P = Activate[Table[Inactive[Function][vars, poly], {poly, basis}]];
			,
			(* basis is provided by user *)
			P = Take[SubOption[OptionValue[Method], "GPCBasis"], order];
			basis = Through[P[Sequence@@vars]]
		];
	
		(* construct a function from expr (and the PDFs) *)
		OptionValue[Monitor]["constructing integrant..."];
		f = Activate[Inactive[Function][vars, expr Times@@Pick[pdfs, noUseAutoRule]]];
		(* inject EvaluationMonitor if required *)
		If[OptionValue[EvaluationMonitor] =!= None,
			f = InterceptedFunction[OptionValue[EvaluationMonitor], f]
		];
	
		(* construct a memory-function since evaluation of f is assumed to be very slow *)
		(* besides storing the result in its own definition, it also adds the result to evalTable *)
		memf[a___] := With[{fa = f[a]}, AppendTo[evalTable, {{a}, fa}]; memf[a] = fa; fa];
		(* check if the evaluation dump file was specified *)
		If[OptionValue["EvaluationDump"] =!= None,
			(* inject EvaluationDumpFunction *)
			f = InterceptedFunction[EvaluationDumpFunction[OptionValue["EvaluationDump"]], f];
			(* see if we can use existing data *)
			If[FileExistsQ[OptionValue["EvaluationDump"]],
				(* load function values which already exist in the dump file *)
				Module[{str, line, count = 0},
					str = OpenRead[OptionValue["EvaluationDump"]];
					Check[
						CheckAbort[
							While[(line = ToExpression@ReadLine[str]) =!= EndOfFile,
								memf[Sequence@@First[line]] = Last[line];
								count++
							];
							Close[str],
							Close[str]
						],
						Close[str];
						Abort[]
					];
					PrintTemporary[ToString[count]<>" points read from "<>OptionValue["EvaluationDump"]]
				]
			]
		];
	
		OptionValue[Monitor]["constructing integration rule..."];
		rulef[d_, n_] := rulef[d, n] = With[{
				bareRule = Switch[If[ListQ[rule], rule[[d]], rule],
					"GaussRule", 
					NIntegrate`GaussRuleData[n, MachinePrecision],
					"ClenshawCurtisRule", 
					NIntegrate`ClenshawCurtisRuleData[n, MachinePrecision],
					"TrapezoidalRule", 
					NIntegrate`TrapezoidalRuleData[n, MachinePrecision],
					"NewtonCotesRule",
					NIntegrate`NewtonCotesRuleData[n, MachinePrecision],
					Automatic,
					ConstructRule[n, distributions[[d]], supports[[d]]],
					Association["Abscissas" -> _, "Weights" -> _],
					{
						Take[If[ListQ[rule], rule[[d]], rule]["Abscissas"], n],
						Take[If[ListQ[rule], rule[[d]], rule]["Weights"], n]
					}
				]
			},
			If[noUseAutoRule[[d]],
				{
					Rescale[bareRule[[1]], {0, 1}, supports[[d]]],
					bareRule[[2]]
				},
				bareRule
			]
		];
	
		gridf = Switch[grid,
			"FullTensorGrid",
			FullTensorGrid,
			"SmolyakSparseGrid",
			SmolyakSparseGrid	
		];
	
		OptionValue[Monitor]["integrating..."];
		a = N@Table[
			gridf[memf[##] P[[k]][##]&, dim, order, rulef, OptionValue[Listable]] Times@@Abs[Subtract@@@Pick[supports, noUseAutoRule]],
			{k, Length[P]}
		];
	
		If[SubOption[OptionValue[Debug], "UsePolynomialApproximation", False] =!= False,
			SubOption[OptionValue[Debug], "UsePolynomialApproximation"][a.basis]
		];
	
		(* compute expectation, variance, etc. *)
		OptionValue[Monitor]["computing moments..."];
		result = If[TrueQ[OptionValue[Abs]],
			ToMomentsAbs[a, basis, Times@@pdfs, vars, supports, OptionValue["Moments"]]
			,
			ToMoments[a, OptionValue["Moments"]]
		];
	
		(* return the result and drop the imaginary part (which should be zero) *)
		If[Re[result] == result, result = Re[result]];
		
		CollocationData[
			<|
				"Method" -> SubOption[OptionValue[Method]],
				"MethodOption" -> OptionValue[Method],
				"RandomDimension" -> dim,
				"MomentList" -> result,
				"ErrorEstimate" -> Indeterminate,
				"BasisFunctions" -> P,
				"CoefficientList" -> a,
				"DistributionList" -> distributions,
				"SupportList" -> supports,
				"CompressedEvaluationTable" -> Compress[evalTable],
				"EvaluationCount" -> Length[evalTable]
			|>
		]
	]
]


PDFEx[distr_] := Switch[distr,
	"Uniform", 
	With[{pdf = PDF[UniformDistribution[{-1,1}]]},
		Activate@MapAt[Simplify`PWToUnitStep, Inactivate[pdf, Function],{2}]
	],
	"Beta", (*Function[\[FormalX], (230945*(1 + (-1 - \[FormalX])/2)^9*(1 + \[FormalX])^9)/256, Listable]*)
	With[{pdf = PDF[TransformedDistribution[2 x - 1, x \[Distributed] BetaDistribution[10,10]]]},
		Activate@MapAt[Simplify`PWToUnitStep, Inactivate[pdf, Function],{2}]
	],
	_, 
	With[{pdf = PDF[distr]},
		Activate@MapAt[Simplify`PWToUnitStep, Inactivate[pdf, Function],{2}]
	]
]

PDFEx[distr_, var_] := Simplify`PWToUnitStep@Switch[distr,
	"Uniform", 
	PDF[UniformDistribution[{-1,1}], var],
	"Beta", 
	PDF[TransformedDistribution[2 x - 1, x \[Distributed] BetaDistribution[10,10]], var],
	_, 
	PDF[distr, var]
]


(*

ConstructRule[n, distr] returns a list with {n abscissas, n weights} for the 
Gauss quadrature with the gPC basis of the given distribution distr.

*)

ConstructRule[n_Integer, distr_, support_:Automatic, OptionsPattern[]] :=
Catch[
	Module[{\[Alpha], \[Beta], jacobi, absc, mgf, weights, eigenvectors},
		(* find the recurrence coefficients \[Alpha] and \[Beta] *)
		OptionValue[Monitor]["finding recurrence coefficients..."];
		Switch[distr,
			(* special cases *)
			"Uniform"|UniformDistribution[{-1,1}],
			Module[{k},
				{\[Alpha], \[Beta]} = abcTo\[Alpha]\[Beta][n, {2-1/k, 0, 1-1/k}, k, MachinePrecision]
			],
			"Beta"|TransformedDistribution[2 \[FormalX] - 1, \[FormalX] \[Distributed] BetaDistribution[10, 10]],
			Module[{k},
				{\[Alpha], \[Beta]} = abcTo\[Alpha]\[Beta][n, {((9+k) (17+2 k))/(k (18+k)), 0, ((8+k) (9+k))/(k (18+k))}, k, MachinePrecision]
			],
			(* general case *)
			_?DistributionParameterQ,
			Module[{a, b, R, r, moments, gramMatrix, x, integrate},
				(* choose an integration routine *)
				integrate = If[PolynomialQ[PDF[distr, \[FormalX]], \[FormalX]], IntegratePolynomial, NIntegrate];
				(* determine the integration interval *)
				If[support === Automatic,
					{a, b} = DistributionSupport[distr],
					{a, b} = support
				];
	
				(* find the recurrence coefficients \[Alpha] and \[Beta] *)
				(* this algorithm is based on Golub-Welsh, http://dx.doi.org/10.1090/s0025-5718-69-99647-1, \[Section]4 *)
			
				OptionValue[Monitor]["generating moments..."];
				moments = Catch[
					If[(mgf = MomentGeneratingFunction[distr, x]) === Indeterminate, Throw[$Failed]];
					(* use the moment-generating function, if available *)
					Check[
						Table[SeriesCoefficient[mgf, {x, 0, i}] i!, {i, 0, 2 n}],
						Throw[$Failed]
					]
				];
				(* check if using the moment generating function has succeded *)
				If[moments === $Failed,
					OptionValue[Monitor]["... $Failed"];
					OptionValue[Monitor]["generating moments by direct integration..."];
					(* use direct integration *)
					moments = With[{pdf = PDF[distr]},
						Table[N@integrate[pdf[x] x^k, {x, a, b}], {k, 0, 2 n}]
					]
				];

				(* use Partition to generate symmetric matrix with *)
				(* gramMatrix[[i+1, j+1]] = gramMatrix[[j+1, i+1]] = moments[[1 + i + j]] *)
				OptionValue[Monitor]["constructing Gram matrix..."];				
				gramMatrix = Partition[moments, n+1, 1];
				
				(* if we work symbolically, spend some time on simplifying the gramMatrix *)
				If[Precision[gramMatrix] == Infinity,
					OptionValue[Monitor]["simplifying Gram matrix..."];
					gramMatrix = Simplify[gramMatrix, TimeConstraint -> 30]
				];

				Assert[PositiveDefiniteMatrixQ[gramMatrix]];
	
				OptionValue[Monitor]["computing Cholesky decomposition..."];
				R = CholeskyDecomposition[gramMatrix];
				Assert[R[[1,1]] == 1];
				Assert[R[[1,2]] == 0];

				r[i_, j_] := R[[i,j]];
				r[0, 0] = 1;
				r[0, 1] = 0;

				OptionValue[Monitor]["building coefficient table..."];
				\[Alpha] = Table[r[j,j+1]/r[j,j] - r[j-1,j]/r[j-1,j-1], {j, 1, n}];
				\[Beta] = Table[r[j+1,j+1]/r[j,j], {j, 1, n - 1}]
			],
			_,
			Message[Collocation::bddistr, distr]; Throw[$Failed]
		];
	
		(* now construct the quadrature abscissas and weights from the recurrence coefficients *)
		(* this algorithm is based on Golub-Welsh, http://dx.doi.org/10.1090/s0025-5718-69-99647-1, \[Section]2 *)
		
		(* construct the Jacobi matrix *)
		OptionValue[Monitor]["constructing Jacobi matrix..."];
		jacobi = SparseArray[{
				Band[{2,1}] -> \[Beta],
				Band[{1,2}] -> \[Beta],
				Band[{1,1}] -> \[Alpha]
			}, n
		];
		
		(* the roots of Subscript[P, N+1](x) are the eigenvalues of J *)
		OptionValue[Monitor]["finding the eigensystem..."];
		{absc, eigenvectors} = Eigensystem[jacobi];
	
		(* we assume that the integral over the weight function is 1, since it is a probability density *)
		(* then the weights are the first components of the eigenvectors *)
		weights = (First /@ Normalize /@ eigenvectors)^2;
		
		{absc, weights}
	]	
]


abcTo\[Alpha]\[Beta][NP_, {a_, b_, c_}, n_, prec_] := {
	N[Table[(b/.n->i)/(a/.n->i), {i, 1, NP - 1}], prec],
	N[Table[(1/(a/.{n->i}) (c/.n->(i+1))/(a/.n->(i+1)))^(1/2), {i, 1, NP-1}], prec]
}


SmolyakSparseGrid[f_, dim_, level_, rule_, listable_] := Module[{coefficient, absk, k, a, w, fvalue, i},
	Sum[
		absk = Sum[k[n], {n, 1, dim}];
		If[level <= absk <= level + dim - 1 && AllTrue[Table[k[n], {n, 1, dim}], GreaterThan[1]],
			coefficient = (-1)^(level + dim - absk - 1) Binomial[dim - 1, absk - level];
			Do[
				{a[i], w[i]} = Take[rule[i, k[i]], 2],
				{i, dim}
			];
			Sum[
				fvalue = f[Sequence@@Table[a[d][[i[d]]], {d, dim}]];
				coefficient Product[w[d][[i[d]]], {d, dim}] fvalue
				,
				Evaluate[Sequence@@Table[{i[n], 1, Length[a[n]]}, {n, dim}]]
			]
			,
			0
		],
		Evaluate[Sequence@@Table[{k[n], 1, level + dim}, {n, dim}]]
	]
]


FullTensorGrid[f_, dim_, level_, rule_, listable_] := Module[{i, a, w, fvalue},
	(* construct quadrature rule in each dimension *)
	Do[
		{a[i], w[i]} = Take[rule[i, level], 2],
		{i, dim}
	]; 
	If[Not@listable || dim > 1,
		Sum[
			fvalue = f[Sequence@@Table[a[d][[i[d]]], {d, dim}]];
			Product[w[d][[i[d]]], {d, dim}] fvalue
			,
			Evaluate[Sequence@@Table[{i[n], 1, Length[a[n]]}, {n, dim}]]
		]
		,
		w[1].f[a[1]]
	]
]


ToMoments[coefs_, n_] := Catch[
	Module[{moments = {}},
		If[!TrueQ[0 < n < 3 && IntegerQ[n]], 
			Message[Collocation::nmom, n];
			Throw[$Failed]
		];
	
		(* check if we are collocating multiple functions at once *)
		If[Head[First[coefs]] === Association,
			(* we are collocating multiple functions at once *)
			(* expectation = NIntegrate[coefs.P pdf[\[Alpha]],{\[Alpha],-1,1}] *)
			AppendTo[moments, coefs[[1]]];
			(* variance = NIntegrate[(coefs.P - expectation)^2 pdf[\[Alpha]],{\[Alpha],-1,1}] *)
			If[n >= 2, AppendTo[moments, Sum[coefs[[i]]^2, {i, 2, Length[coefs]}]]];
			AssociationThread[Keys@First@moments -> Transpose[List@@@moments]]
			,
			(* we collocate a single scalar function *)
			(* expectation = NIntegrate[coefs.P pdf[\[Alpha]],{\[Alpha],-1,1}] *)
			AppendTo[moments, coefs[[1]]];
			(* variance = NIntegrate[(coefs.P - expectation)^2 pdf[\[Alpha]],{\[Alpha],-1,1}] *)
			If[n >= 2, AppendTo[moments, Rest[coefs].Rest[coefs]]];
			moments
		]
	]
]


ToMomentsAbs[coefs_, P_, pdf_, vars_, supports_, n_] := Catch[
	Module[{keys, moments},
		If[!TrueQ[0 < n < 3 && IntegerQ[n]], 
			Message[Collocation::nmom, n];
			Throw[$Failed]
		];
	
		(* check if we are collocating multiple functions at once *)
		If[Head[First[coefs]] === Association,
			(* we are collocating multiple functions at once *)
			keys = Keys@First[coefs];
			AssociationThread[
				keys -> Table[
					With[{expectation = Abs[NIntegrate[Abs[coefs[[All, key]].P] pdf, Evaluate[Sequence@@(Flatten/@Thread[{vars, supports}])]]]},
						{
							expectation,
							If[n >= 2, Abs[coefs[[All, key]].Conjugate[coefs[[All, key]]] - expectation^2], Nothing]
						}
					]
					,
					{key, Length@keys}
				]
			]
			,
			(* we collocate a single scalar function *)
			moments = {};
			(* expectation = NIntegrate[coefs.P pdf[\[Alpha]],{\[Alpha],-1,1}] *)
			AppendTo[moments, NIntegrate[Abs[coefs.P] pdf, Evaluate[Sequence@@(Flatten/@Thread[{vars, supports}])]]];
			(* variance = NIntegrate[(Abs[coefs.P]-expectation)^2 pdf[\[Alpha]], {\[Alpha],-1,1}] *)
			If[n >= 2, AppendTo[moments, coefs.Conjugate[coefs] - First[moments]^2]];
			moments
		]
	]
]


(* ::Subsubsection:: *)
(*`Collocation`MonteCarlo*)


Options[`Collocation`MonteCarlo] = {
	Method -> "MonteCarlo",
	"DistributionSupport" -> Automatic,
	Listable -> False,
	Abs -> False,
	EvaluationMonitor -> None,
	"Moments" -> 2,
	Monitor -> None
};

Collocation::mcnsd = "Warning: Not all distributions are identical.";

`Collocation`MonteCarlo[expr_, args:{(*x*)_, (*distr*)_}.., n_Integer, supports_, options:OptionsPattern[]] := Catch[
	Module[{dim = Length[{args}], specialDistributions, oneDistr, f, pts, fvalues, evalTable = {}, result, error},

		oneDistr = TrueQ[SameQ@@(Last /@ {args})];
		(* ToDo: handle case of unsame distributions *)
		If[Not[oneDistr], Message[Collocation::mcnsd]];
	
		specialDistributions = {
			"Uniform" -> UniformDistribution[{-1,1}],
			"Beta" -> TransformedDistribution[2 \[FormalX] - 1, \[FormalX] \[Distributed] BetaDistribution[10,10]]
		};

		OptionValue[Monitor]["constructing evaluation function..."];
		f = Activate@Inactive[Function][First/@{args}, expr];
	
		(* inject EvaluationMonitor if required *)
		If[OptionValue[EvaluationMonitor] =!= None,
			f = InterceptedFunction[OptionValue[EvaluationMonitor], f]
		];
		
		(* inject storage function *)
		f = InterceptedFunction[AppendTo[evalTable, {##}]&, f];
	
		OptionValue[Monitor]["generating random absciccas ("<>SubOption[OptionValue[Method]]<>")..."];
		pts = BlockRandom[
			Which[
				SubOption[OptionValue[Method]] == "MonteCarlo",
				SeedRandom[
					SubOption[OptionValue[Method], RandomSeed, Automatic],
					Method -> "ExtendedCA"
				],
				SubOption[OptionValue[Method]] == "QuasiMonteCarlo",
				SeedRandom[
						SubOption[OptionValue[Method], RandomSeed, Automatic], 
					Method -> {"MKL", Method -> {"Sobol", "Dimension" -> If[oneDistr, dim, 1]}}
				],
				True,
				Message[Collocation::bdmtd, SubOption[OptionValue[Method]]]; Throw[$Failed]
			]; 
			If[oneDistr,
				RandomVariate[{args}[[1,2]] /. specialDistributions, {(n + 1)^dim, dim}]
				,
				Tuples[
					Table[
						RandomVariate[d /. specialDistributions, n + 1],
						{d, Last/@{args}}
					]
				]
			]
		];
	
		(* evaluate f at root locations *)
		OptionValue[Monitor]["evaluating function..."];
		If[TrueQ@OptionValue[Listable],
			(* assume f is Listable *)
			fvalues = f[pts],
			(* assume f is not Listable *) 
			fvalues = Apply[Sequence, Thread[Inactive[f][pts]], {2}] // Activate
		];	
	
		(* take absolute values if Abs is True *)
		OptionValue[Monitor]["taking absolute values..."];
		If[TrueQ[OptionValue[Abs]], 
			fvalues = Abs[fvalues]
		];

		(* compute the central moments *)
		OptionValue[Monitor]["computing moments..."];
		If[Head@First@fvalues === Association,
			result = AssociationThread[
				Keys[fvalues[[1]]]->(
					({Mean[#], If[OptionValue["Moments"] >= 2, Variance[#], Nothing]})&/@Transpose[List@@@fvalues]
				)
			],
			result = {
				Mean[fvalues],
				If[OptionValue["Moments"] >= 2, Variance[fvalues], Nothing]
			}
		];
		
		error = Switch[SubOption[OptionValue[Method]], 
			"MonteCarlo",
			1 / Sqrt[n + 1],
			"QuasiMonteCarlo",
			Log[n + 1]^dim / (n + 1),
			_,
			Indeterminate
		];
	
		CollocationData[
			<|
				"Method" -> SubOption[OptionValue[Method]],
				"MethodOption" -> OptionValue[Method],
				"RandomDimension" -> dim,
				"MomentList" -> result,
				"ErrorEstimate" -> error,
				"BasisFunctions" -> Missing["NotApplicable"],
				"CoefficientList" -> Missing["NotApplicable"],
				"DistributionList" -> (Last/@{args}),
				"SupportList" -> supports,
				"CompressedEvaluationTable" -> Compress[evalTable],
				"EvaluationCount" -> Length[evalTable]
			|>
		]
	]
]


InterceptedFunction[g_, f_Function] := Function[
	With[{fx = f[##]},
		g[{##}, fx]; fx
	]
]


(* ::Subsubsection:: *)
(*"EvaluationDump"*)


EvaluationDumpFunction[filename_] := Function[PutAppend[{##}, filename]] /;
If[DirectoryQ[DirectoryName[filename]], True, Message[Collocation::nodir, DirectoryName[filename]]; Abort[]]


(* ::Subsection:: *)
(*CollocationData*)


(* ::Subsubsection:: *)
(*Format*)


Do[
	With[{f = form},
		Format[cd:CollocationData[data___], f] := With[{
				numAbsc = cd["EvaluationCount"],
				mtd = cd["Method"],
				mean = cd["Mean"],
				variance = cd["Variance"]
			}, 
			summaryForm[
				"CollocationData",
				(* calling EvaluationTable (Uncompress) is ok since the icon gets computed only once *)
				Histogram[Last/@cd["EvaluationTable"],
					PerformanceGoal->"Speed",
					PlotTheme->"Minimal",
					Axes->None,Frame->True,
					ChartStyle->ColorData[112,2],
					Background->White
				],
				{
					{"EvaluationCount: ", numAbsc}, 
					{"Result: ", Row[{N[mean], " \[PlusMinus] ", N[variance]}]},
					{"Method: ", mtd}
				}, 2,
				f,
				CollocationData[data]
			]
		]
	],
	{form, {StandardForm, TraditionalForm}}
]


ClearAll[summaryForm];
summaryForm[name_, icon_, infos_, maxInfos_, form_, expr_] := RawBoxes@Quiet@Check[
	Module[{shown, hidden},
		(* convert info-table into summary items *)
		{shown, hidden} = Map[BoxForm`MakeSummaryItem[#, form]&, TakeDrop[infos, maxInfos], {2}];
		(* arrange the summary and make sure the label is gray (therefore StyleBox) *)
		StyleBox[BoxForm`ArrangeSummaryBox[
			name, 
			expr,
			Deploy@Show[icon, 
				(* avoid gray background before mouse-over *)
				Background -> White, 
				(* set standard image size *)
				ImageSize -> Dynamic[{
					Automatic, 
					3.5 CurrentValue["FontCapHeight"]/AbsoluteCurrentValue[Magnification]
				}]
			],
			shown,
			hidden,
			form,
			(* formatted object should be uasable as input *)
			"Interpretable" -> True
		], "NonInterpretableSummary"]
	],
	(* in case something goes wrong *)
	ToBoxes@Panel@Short[expr]
]


(* ::Subsubsection:: *)
(*Access*)


CollocationData[data_, ___][key_String] := data[key]


CollocationData[data_, ___]["EvaluationTable"] := Uncompress[data["CompressedEvaluationTable"]]


CollocationData[data_, ___]["Mean"] := With[{moments = data["MomentList"]}, If[Length[moments] >= 1, moments[[1]], Missing["NotAvailable"]]]
CollocationData[data_, ___]["Variance"] := With[{moments = data["MomentList"]}, If[Length[moments] >= 2, moments[[2]], Missing["NotAvailable"]]]
CollocationData[data_, ___]["Skewness"] := With[{moments = data["MomentList"]}, If[Length[moments] >= 3, moments[[3]], Missing["NotAvailable"]]]


CollocationData[data_, ___]["StandardDeviation"] := With[{moments = data["MomentList"]}, If[Length[moments] >= 2, Sqrt[moments[[2]]], Missing["NotAvailable"]]]


CollocationData[data_, ___]["BasisFunctions", x_] := If[!MissingQ[data["BasisFunctions"]], Through[data["BasisFunctions"][x]], data["BasisFunctions"]]


CollocationData[data_, ___]["Properties"] := With[{moments = data["MomentList"]},
	Sort@DeleteDuplicates@Flatten[{
		"EvaluationTable",
		Take[{"Mean", "Variance", "Skewness"}, Length[moments]],
		If[Length[moments] >= 2, "StandardDeviation", Nothing],
		If[!MissingQ[data["BasisFunctions"]], "BasisFunctions", Nothing],
		Keys@DeleteMissing[data]
	}]
]


(* ::Section:: *)
(*End Package*)


End[] (* `Private` *)


End[] (* PolynomialChaos` *)


EndPackage[] (* PolynomialChaos` *)
